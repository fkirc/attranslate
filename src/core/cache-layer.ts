import { CliArgs, CoreResults, TSet } from "./core-definitions";
import { existsSync } from "fs";
import { checkDir, getDebugPath } from "../util/util";
import path from "path";
import { parseTCache } from "./cache-parsing";
import { writeManagedJson } from "../file-formats/common/managed-json";

export interface TCache {
  "generated-by-attranslate"?: string;
  source?: string;
  version: { major: number; minor: number };
  entries: Record<string, TCacheEntry>;
}

export interface TCacheEntry {
  value: string | null;
  targets: TCacheTarget[];
}

type TCacheTargetState = "needs_update" | "frozen";

export interface TCacheTarget {
  id: string;
  state: TCacheTargetState;
}

let lastReadCache: TCache | null = null;
let tCacheTargetMiss = false;

function resolveCachePath(args: CliArgs): string {
  const cacheDir = args.cacheDir;
  checkDir(cacheDir);
  const baseName = path.basename(args.srcFile);
  const cacheName = `attranslate-cache_from-${args.srcLng}_to-${args.targetFormat}_src-${baseName}.json`;
  return path.resolve(cacheDir, cacheName);
}

function getCacheWarning(args: CliArgs): string {
  return `Do not edit this file manually! You may want to edit '${args.srcFile}' instead.`;
}

export function missingTCacheTarget() {
  return tCacheTargetMiss;
}

export function resolveTCache(src: TSet, args: CliArgs): TSet | null {
  const cachePath = resolveCachePath(args);
  if (!existsSync(cachePath)) {
    return null;
  }
  const tCache: TCache = parseTCache({ cachePath });
  lastReadCache = tCache;
  const internalCache: TSet = new Map();
  Object.keys(tCache.entries).forEach((key: string) => {
    const entry = tCache.entries[key];
    const internalEntry = cacheEntryToInternalEntry(key, entry, src, args);
    internalCache.set(key, internalEntry);
  });
  return internalCache;
}

export function writeTCache(results: CoreResults, args: CliArgs) {
  const cachePath = resolveCachePath(args);
  console.info(`Write cache ${getDebugPath(cachePath)}`);

  const cache: TCache = {
    "generated-by-attranslate": getCacheWarning(args),
    source: args.srcFile,
    version: { major: 1, minor: 0 },
    entries: {},
  };
  results.newSrcCache.forEach((value, key) => {
    cache.entries[key] = internalEntryToCacheEntry(key, value, args);
  });

  writeManagedJson({ path: cachePath, object: cache });
}

function getTargetId(args: CliArgs) {
  return args.targetLng;
}

function cacheEntryToInternalEntry(
  key: string,
  entry: TCacheEntry,
  src: TSet,
  args: CliArgs
): string | null {
  const targetId = getTargetId(args);
  const target = entry.targets.find((target) => target.id === targetId);
  if (!target) {
    tCacheTargetMiss = true;
    return entry.value;
  }
  const srcEntry = src.get(key);
  if (srcEntry !== entry.value) {
    return entry.value;
  }
  if (target.state !== "needs_update") {
    return entry.value;
  } else {
    // This is a case where we want to enforce an update even if the cache value is up-to-date.
    return srcEntry !== null ? null : " ";
  }
}

function internalEntryToCacheEntry(
  key: string,
  internalEntry: string | null,
  args: CliArgs
): TCacheEntry {
  const oldEntry: TCacheEntry | undefined = lastReadCache?.entries[key];
  const valueChanged: boolean = oldEntry
    ? oldEntry.value !== internalEntry
    : false;
  const targetId = getTargetId(args);
  const newTarget: TCacheTarget = {
    id: targetId,
    state: "frozen",
  };
  let oldTargetIncluded = false;
  const newTargets: TCacheTarget[] = !!oldEntry
    ? oldEntry.targets.map((oldTarget: TCacheTarget) => {
        if (oldTarget.id === targetId) {
          oldTargetIncluded = true;
          return newTarget;
        } else if (valueChanged) {
          return { ...oldTarget, state: "needs_update" };
        } else {
          return oldTarget;
        }
      })
    : [];
  if (!oldTargetIncluded) {
    newTargets.push(newTarget);
  }
  return {
    value: internalEntry,
    targets: newTargets,
  };
}
